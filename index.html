<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RailVerse (全国版) - MapLibre GL JS Edition</title>
    
    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    
    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; background: #000; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            width: 320px;
            backdrop-filter: blur(10px);
            transition: background 0.3s, color 0.3s;
            max-height: 90vh;
            overflow-y: auto;
        }

        .dark-mode #ui-layer {
            background: rgba(20, 20, 30, 0.85);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
        }

        h1 { margin: 0 0 5px 0; font-size: 24px; font-weight: 700; letter-spacing: -0.5px; }
        .subtitle { font-size: 12px; color: #666; margin-bottom: 15px; }
        .dark-mode .subtitle { color: #aaa; }

        /* Status Bar */
        #status-bar {
            font-size: 11px;
            padding: 5px 10px;
            background: #eee;
            border-radius: 4px;
            margin-bottom: 15px;
            color: #555;
            border-left: 4px solid #2ecc71;
        }
        .dark-mode #status-bar { background: #333; color: #ccc; border-left-color: #00f2ff; }

        /* Toggle Switch */
        .mode-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #eee;
            border-radius: 30px;
            padding: 5px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s;
            margin-bottom: 15px;
        }
        .dark-mode .mode-switch { background: #333; }

        .mode-label {
            flex: 1;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            z-index: 2;
            padding: 8px 0;
            transition: color 0.3s;
        }
        
        .mode-indicator {
            position: absolute;
            width: 50%;
            height: calc(100% - 10px);
            background: #fff;
            border-radius: 25px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            left: 5px;
        }
        
        .dark-mode .mode-indicator {
            transform: translateX(100%);
            background: #00f2ff; /* Neon Cyan */
            box-shadow: 0 0 15px #00f2ff;
        }

        .active { color: #000; }
        .dark-mode .active { color: #000; text-shadow: none; }
        .inactive { color: #999; }

        /* Legend Panel */
        #legend-container {
            margin-top: 15px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .legend-toggle {
            cursor: pointer;
            font-size: 12px;
            color: #555;
            text-decoration: underline;
            margin-bottom: 5px;
            display: block;
        }
        .legend-list {
            display: none; /* Hidden by default */
            max-height: 200px;
            overflow-y: auto;
        }
        .legend-list.show {
            display: block;
        }
        .legend-item { display: flex; align-items: center; margin-top: 8px; font-size: 12px; }
        .color-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }

        /* Line Details Panel */
        #line-details-panel {
            position: absolute;
            top: 20px;
            right: -350px; /* Hidden by default */
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 8px;
            box-shadow: -4px 0 12px rgba(0,0,0,0.1);
            transition: right 0.3s ease-in-out;
            z-index: 2;
            max-height: 90vh;
            overflow-y: auto;
        }
        #line-details-panel.active {
            right: 20px;
        }
        .dark-mode #line-details-panel {
            background: rgba(20, 20, 30, 0.95);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .line-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .dark-mode .line-header { border-bottom-color: #444; }
        .line-logo {
            width: 40px;
            height: 40px;
            background: #ccc;
            border-radius: 4px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .line-info h2 {
            margin: 0;
            font-size: 18px;
        }
        .line-info p {
            margin: 2px 0 0;
            font-size: 12px;
            color: #666;
        }
        .dark-mode .line-info p { color: #aaa; }
        .station-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .station-item {
            padding: 8px 5px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 13px;
            display: flex;
            align-items: center;
        }
        .dark-mode .station-item { border-bottom-color: #444; }
        .station-marker {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
            margin-right: 10px;
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-size: 18px;
            color: #999;
        }
        .close-btn:hover { color: #333; }
    </style>
</head>
<body>

    <div id="map"></div>
    
    <div id="ui-layer">
        <h1>RailVerse <span style="font-size: 12px; font-weight: normal; opacity: 0.7;">(MapLibre版)</span></h1>
        <div class="subtitle">WebGL高速描画エンジン搭載</div>

        <div id="status-bar">データを読み込み中...</div>

        <div class="mode-switch" onclick="toggleMode()">
            <div class="mode-indicator"></div>
            <div class="mode-label active" id="label-day">DAY (地上)</div>
            <div class="mode-label inactive" id="label-night">NIGHT (地下)</div>
        </div>

        <div id="legend-container">
            <div class="legend-toggle" onclick="toggleLegend()">路線凡例を表示/非表示</div>
            <div id="legend-list" class="legend-list">
                <!-- Dynamically populated -->
            </div>
        </div>
    </div>

    <div id="line-details-panel">
        <div class="close-btn" onclick="hideLineDetails()">×</div>
        <div class="line-header">
            <div class="line-logo" id="detail-logo">JR</div>
            <div class="line-info">
                <h2 id="detail-name">路線名</h2>
                <p id="detail-company">鉄道会社</p>
            </div>
        </div>
        <div id="detail-content">
            <p style="font-size:12px; color:#888; margin-bottom:5px;">駅一覧:</p>
            <ul class="station-list" id="detail-stations">
                <!-- Stations go here -->
            </ul>
        </div>
    </div>

    <script>
        // --- Configuration ---
        // (Regions removed)

        // --- State ---
        let map;
        let isUnderground = false;
        const loadedRealTrackExtents = [];
        const lineDataCache = {}; // Cache for station lists: { lineCd: { ...data } }
        
        // External Data Cache
        let externalLineData = {}; // Map<LineName, { color, logo, company }>

        // GeoJSON Data Store
        let geojsonData = {
            type: 'FeatureCollection',
            features: []
        };

        // Overpass State
        let isOverpassLoading = false;
        let overpassDebounceTimer = null;

        // --- Initialization ---
        window.onload = async function() {
            initMap();
            await fetchExternalMetadata();
            loadAllRailways(); // Start loading everything
        };

        async function fetchExternalMetadata() {
            updateStatus("外部メタデータ(Wikidata等)を取得中...");
            try {
                // 1. Fetch Colors from Mini Tokyo 3D (High quality for Tokyo)
                const colorRes = await fetch('https://raw.githubusercontent.com/nagix/mini-tokyo-3d/master/data/railways.json');
                const colorData = await colorRes.json();

                // 2. Fetch Logos from Open Data JP Railway Lines
                const logoRes = await fetch('https://raw.githubusercontent.com/piuccio/open-data-jp-railway-lines/master/lines.json');
                const logoData = await logoRes.json();

                // 3. Fetch Nationwide Data from Wikidata (SPARQL)
                // Gets line colors (P465), logos (P154), and route numbers (P1671/P1801)
                const sparqlQuery = `
                    SELECT DISTINCT ?lineLabel ?hexColor ?logo ?code WHERE {
                      ?line wdt:P31/wdt:P279* wd:Q1142127;
                            wdt:P17 wd:Q17.
                      OPTIONAL { ?line wdt:P465 ?hexColor. }
                      OPTIONAL { ?line wdt:P154 ?logo. }
                      OPTIONAL { ?line wdt:P1671 ?code. }
                      OPTIONAL { ?line wdt:P1801 ?code. }
                      SERVICE wikibase:label { bd:serviceParam wikibase:language "ja,en". }
                    }
                    LIMIT 5000
                `;
                const wikidataUrl = `https://query.wikidata.org/sparql?query=${encodeURIComponent(sparqlQuery)}&format=json`;
                
                let wikidataItems = [];
                try {
                    const wdRes = await fetch(wikidataUrl, { headers: { 'Accept': 'application/sparql-results+json' } });
                    if (wdRes.ok) {
                        const wdJson = await wdRes.json();
                        wikidataItems = wdJson.results.bindings;
                        console.log(`Wikidata loaded: ${wikidataItems.length} items`);
                    }
                } catch (e) {
                    console.warn("Wikidata fetch failed", e);
                }

                // 4. Build Lookup Map
                // Priority: Mini Tokyo 3D > Wikidata > Open Data JP
                
                // Helper to normalize names for matching
                const normalize = (name) => name.replace(/^JR/, '').replace(/線$/, '').replace(/[（\(].*?[）\)]/g, '').trim();

                // Process Wikidata (Base Layer)
                wikidataItems.forEach(item => {
                    const name = item.lineLabel.value;
                    const normName = normalize(name);
                    
                    if (!externalLineData[normName]) externalLineData[normName] = {};
                    
                    if (item.hexColor) {
                        externalLineData[normName].color = '#' + item.hexColor.value;
                    }
                    if (item.logo) {
                        externalLineData[normName].logo = item.logo.value;
                    }
                    if (item.code) {
                        externalLineData[normName].code = item.code.value;
                    }
                });

                // Process Open Data JP (Middle Layer)
                logoData.forEach(line => {
                    if (line.name_ja) {
                        const normName = normalize(line.name_ja);
                        if (!externalLineData[normName]) externalLineData[normName] = {};
                        if (line.logo) externalLineData[normName].logo = line.logo;
                    }
                });

                // Process Mini Tokyo 3D (Top Layer - Best Colors for Tokyo)
                colorData.forEach(line => {
                    if (line.title && line.title.ja) {
                        const name = line.title.ja;
                        const normName = normalize(name);
                        
                        if (!externalLineData[normName]) externalLineData[normName] = {};
                        externalLineData[normName].color = line.color;
                        
                        if (line.id.includes("JR-East")) externalLineData[normName].company = "JR東日本";
                        else if (line.id.includes("TokyoMetro")) externalLineData[normName].company = "東京メトロ";
                        else if (line.id.includes("Toei")) externalLineData[normName].company = "都営地下鉄";
                    }
                });

                console.log("External metadata loaded:", Object.keys(externalLineData).length, "lines");
                updateStatus("外部メタデータの読み込み完了");

            } catch (e) {
                console.error("Failed to load external metadata", e);
                updateStatus("外部メタデータの読み込みに失敗しました (デフォルト色を使用)");
            }
        }

        // (initUI removed)

        function initMap() {
            map = new maplibregl.Map({
                container: 'map',
                // Use local fonts for CJK to improve performance and avoid 404s
                localIdeographFontFamily: "'Meiryo', 'Hiragino Kaku Gothic ProN', 'MS PGothic', 'sans-serif'",
                style: {
                    version: 8,
                    // Use Geolonia's public glyphs for reliable Japanese font support
                    glyphs: "https://glyphs.geolonia.com/{fontstack}/{range}.pbf",
                    sources: {
                        'carto-light': {
                            type: 'raster',
                            tiles: ['https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'],
                            tileSize: 256,
                            attribution: '&copy; OSM &copy; CARTO'
                        },
                        'carto-dark': {
                            type: 'raster',
                            tiles: ['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'],
                            tileSize: 256,
                            attribution: '&copy; OSM &copy; CARTO'
                        },
                        'railways': {
                            type: 'geojson',
                            data: geojsonData
                        }
                    },
                    layers: [
                        {
                            id: 'base-tiles',
                            type: 'raster',
                            source: 'carto-light',
                            minzoom: 0,
                            maxzoom: 22
                        },
                        // --- Real Tracks (Overpass) ---
                        {
                            id: 'real-tracks',
                            type: 'line',
                            source: 'railways',
                            filter: ['==', ['get', 'type'], 'real-track'],
                            paint: {
                                'line-color': '#888',
                                'line-width': 1,
                                'line-opacity': 0.6
                            }
                        },
                        // --- Spline Lines (Glow/Casing) ---
                        {
                            id: 'rail-lines-glow',
                            type: 'line',
                            source: 'railways',
                            filter: ['in', ['get', 'type'], ['literal', ['ground', 'subway']]],
                            paint: {
                                'line-color': ['get', 'color'],
                                'line-width': [
                                    'interpolate', ['linear'], ['zoom'],
                                    5, 2,
                                    12, 8
                                ],
                                'line-opacity': 0.3,
                                'line-blur': 2
                            }
                        },
                        // --- Spline Lines (Core) ---
                        {
                            id: 'rail-lines-core',
                            type: 'line',
                            source: 'railways',
                            filter: ['in', ['get', 'type'], ['literal', ['ground', 'subway']]],
                            paint: {
                                'line-color': ['get', 'color'],
                                'line-width': [
                                    'interpolate', ['linear'], ['zoom'],
                                    5, 1,
                                    12, 3
                                ]
                            }
                        },
                        // --- Stations (Points) ---
                        {
                            id: 'stations-points',
                            type: 'circle',
                            source: 'railways',
                            filter: ['==', ['get', 'type'], 'station'],
                            minzoom: 9, // Performance: Only show dots when zoomed in
                            paint: {
                                'circle-radius': [
                                    'interpolate', ['linear'], ['zoom'],
                                    9, 2,
                                    14, 5
                                ],
                                'circle-color': '#fff',
                                'circle-stroke-width': 1,
                                'circle-stroke-color': '#555'
                            }
                        },
                        // --- Station Labels ---
                        {
                            id: 'stations-labels',
                            type: 'symbol',
                            source: 'railways',
                            filter: ['==', ['get', 'type'], 'station'],
                            minzoom: 12, // Performance: Only show text when very close
                            layout: {
                                'text-field': ['get', 'name'],
                                // Use Noto Sans CJK JP Bold which is available on Geolonia's server
                                'text-font': ['Noto Sans CJK JP Bold'],
                                'text-size': 12,
                                'text-offset': [0, 1.2],
                                'text-anchor': 'top'
                            },
                            paint: {
                                'text-color': '#000',
                                'text-halo-color': '#fff',
                                'text-halo-width': 2
                            }
                        }
                    ]
                },
                center: [139.7671, 35.6812], // Default to Tokyo
                zoom: 10
            });

            // Popup
            const popup = new maplibregl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mouseenter', 'stations-points', (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const coordinates = e.features[0].geometry.coordinates.slice();
                const description = e.features[0].properties.name;
                popup.setLngLat(coordinates).setHTML(description).addTo(map);
            });

            map.on('mouseleave', 'stations-points', () => {
                map.getCanvas().style.cursor = '';
                popup.remove();
            });

            // Dynamic Loading (Global) with Debounce
            map.on('moveend', () => {
                if (overpassDebounceTimer) clearTimeout(overpassDebounceTimer);
                overpassDebounceTimer = setTimeout(loadRealTracksInView, 500); // Wait 500ms after move ends
            });

            // Click Listeners for Line Details
            const lineLayers = ['rail-lines-core', 'rail-lines-glow'];
            lineLayers.forEach(layerId => {
                map.on('click', layerId, (e) => {
                    const props = e.features[0].properties;
                    if (props.lineCd) {
                        showLineDetails(props.lineCd);
                    }
                });
                
                // Change cursor on hover
                map.on('mouseenter', layerId, () => {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', layerId, () => {
                    map.getCanvas().style.cursor = '';
                });
            });
        }

        // --- Core Logic ---
        async function loadAllRailways() {
            updateStatus("全国の路線データを読み込み開始...");
            
            // Iterate through all prefectures (1 to 47)
            // To avoid freezing the UI, we process them in chunks
            const PREF_COUNT = 47;
            let totalLines = 0;

            for (let prefCode = 1; prefCode <= PREF_COUNT; prefCode++) {
                updateStatus(`都道府県データ読み込み中: ${prefCode}/${PREF_COUNT}`);
                const count = await fetchPrefectureLines(prefCode);
                totalLines += count;
                
                // Small delay to let UI breathe
                if (prefCode % 5 === 0) await new Promise(r => setTimeout(r, 100));
            }
            
            updateStatus(`全データ読み込み完了: ${totalLines}路線`);
            // Trigger initial Overpass load
            loadRealTracksInView();
        }

        async function fetchPrefectureLines(prefCode) {
            const url = `https://ny-a.github.io/ekidata/api/p/${prefCode}.json`;
            try {
                const response = await fetch(url);
                if (!response.ok) return 0;
                
                const data = await response.json();
                const lines = data.line;
                if (!lines) return 0;

                const BATCH_SIZE = 50; 
                let newFeatures = [];

                for (let i = 0; i < lines.length; i += BATCH_SIZE) {
                    const batch = lines.slice(i, i + BATCH_SIZE);
                    const batchFeatures = await Promise.all(batch.map(l => fetchLineDetails(l.line_cd, l.line_name)));
                    
                    batchFeatures.flat().forEach(f => {
                        if (f) newFeatures.push(f);
                    });

                    if (newFeatures.length > 0) {
                        geojsonData.features.push(...newFeatures);
                        map.getSource('railways').setData(geojsonData);
                        newFeatures = [];
                    }
                    await new Promise(r => setTimeout(r, 10));
                }
                return lines.length;
            } catch (e) {
                console.warn(`Failed to load pref ${prefCode}`, e);
                return 0;
            }
        }

        async function fetchLineDetails(lineCd, lineName) {
            const url = `https://ny-a.github.io/ekidata/api/l/${lineCd}.json`;
            try {
                const response = await fetch(url);
                if (!response.ok) return [];
                const data = await response.json();
                const stations = data.station_l;
                if (!stations) return [];

                // Cache data for UI
                lineDataCache[lineCd] = data;

                const color = getLineColor(lineName);
                const isSubway = lineName.includes("地下鉄") || lineName.includes("メトロ") || lineName.includes("都営");
                
                const rawPath = [];
                const features = [];

                stations.forEach(st => {
                    rawPath.push([st.lon, st.lat]);
                    features.push({
                        type: 'Feature',
                        geometry: { type: 'Point', coordinates: [st.lon, st.lat] },
                        properties: {
                            type: 'station',
                            color: color,
                            name: st.station_name,
                            lineCd: lineCd,
                            lineName: lineName
                        }
                    });
                });

                if (rawPath.length > 1) {
                    // Hide schematic lines for long-distance trains or sparse stops to avoid "straight line" artifacts
                    // These will be covered by Overpass (Real Tracks)
                    if (lineName.includes("成田エクスプレス") || 
                        lineName.includes("新幹線") || 
                        lineName.includes("特急") || 
                        lineName.includes("ライナー")) {
                        return features;
                    }

                    // Split path into segments based on distance to prevent "jumps" (e.g. complex branching lines like JR Narita Line)
                    const segments = [];
                    let currentSegment = [rawPath[0]];
                    const DISTANCE_THRESHOLD_KM = 15; // Break line if stations are > 15km apart

                    for (let i = 1; i < rawPath.length; i++) {
                        const prev = rawPath[i-1];
                        const curr = rawPath[i];
                        const dist = getDistanceKm(prev[1], prev[0], curr[1], curr[0]);

                        if (dist > DISTANCE_THRESHOLD_KM) {
                            // End current segment
                            if (currentSegment.length > 1) segments.push(currentSegment);
                            // Start new segment
                            currentSegment = [curr];
                        } else {
                            currentSegment.push(curr);
                        }
                    }
                    if (currentSegment.length > 1) segments.push(currentSegment);

                    // Generate Splines for each segment
                    segments.forEach(seg => {
                        const smoothedPath = getCatmullRomSpline(seg, 4);
                        features.push({
                            type: 'Feature',
                            geometry: { type: 'LineString', coordinates: smoothedPath },
                            properties: {
                                type: isSubway ? 'subway' : 'ground',
                                color: color,
                                lineCd: lineCd,
                                lineName: lineName
                            }
                        });
                    });
                }
                return features;

            } catch (e) {
                return [];
            }
        }

        async function loadRealTracksInView() {
            if (isOverpassLoading) return;

            const zoom = map.getZoom();
            // Safety check: Don't load Overpass if zoom is too low (too much data)
            // Even if user said "always", loading at zoom 5 will fail.
            if (zoom < 7) return;

            const bounds = map.getBounds();
            const center = bounds.getCenter();
            
            // Check if current view is already covered by loaded extents
            // We check if the center is in a loaded box, AND if the box is reasonably large enough
            const isLoaded = loadedRealTrackExtents.some(b => b.contains(center));
            if (isLoaded) return;

            isOverpassLoading = true;
            updateStatus("詳細線路データを取得中 (Overpass API)...");

            // Expand bounds slightly to avoid frequent re-fetching
            const expandedBounds = new maplibregl.LngLatBounds(
                [bounds.getWest() - 0.02, bounds.getSouth() - 0.02],
                [bounds.getEast() + 0.02, bounds.getNorth() + 0.02]
            );
            
            const bbox = `${expandedBounds.getSouth()},${expandedBounds.getWest()},${expandedBounds.getNorth()},${expandedBounds.getEast()}`;
            const query = `
                [out:json][timeout:25];
                (
                  way["railway"~"^(rail|subway|monorail)$"]["service"!~"^(yard|siding|spur)$"](${bbox});
                );
                out geom;
            `;
            
            try {
                const response = await fetch("https://overpass-api.de/api/interpreter", { method: 'POST', body: query });
                if (!response.ok) {
                    if (response.status === 429) {
                        console.warn("Overpass API rate limit exceeded. Retrying later.");
                    }
                    throw new Error("Overpass API request failed");
                }
                
                const data = await response.json();
                const newFeatures = [];
                
                data.elements.forEach(element => {
                    if (element.type === 'way' && element.geometry) {
                        const coords = element.geometry.map(pt => [pt.lon, pt.lat]);
                        newFeatures.push({
                            type: 'Feature',
                            geometry: { type: 'LineString', coordinates: coords },
                            properties: {
                                type: 'real-track',
                                color: '#888'
                            }
                        });
                    }
                });
                
                if (newFeatures.length > 0) {
                    geojsonData.features.push(...newFeatures);
                    map.getSource('railways').setData(geojsonData);
                    updateStatus(`実形状データ: ${newFeatures.length}件を追加読み込みしました`);
                    loadedRealTrackExtents.push(expandedBounds);
                } else {
                    updateStatus("実形状データ: 範囲内に見つかりませんでした");
                }
                
            } catch (e) {
                console.warn("Dynamic Overpass fetch failed", e);
                updateStatus("詳細データの取得に失敗しました");
            } finally {
                isOverpassLoading = false;
            }
        }

        // --- UI Logic ---
        function showLineDetails(lineCd) {
            const data = lineDataCache[lineCd];
            if (!data) return;

            const lineName = data.line_name;
            const cleanName = lineName.replace(/^JR/, '');
            
            // Fetch from External Data
            const meta = externalLineData[cleanName] || externalLineData[lineName] || {};
            
            // Fallback for metadata
            const color = meta.color || getLineColor(lineName);
            const logoUrl = meta.logo; // URL if available
            const company = meta.company || "鉄道会社";

            // Update UI
            document.getElementById('detail-name').innerText = lineName;
            document.getElementById('detail-company').innerText = company;
            
            const logoEl = document.getElementById('detail-logo');
            logoEl.style.backgroundColor = color;
            
            if (logoUrl) {
                logoEl.innerHTML = `<img src="${logoUrl}" style="width:100%; height:100%; object-fit:contain;">`;
                logoEl.style.background = 'transparent'; // Use transparent if image exists
            } else {
                // Generate Fallback Logo
                const code = meta.code;
                logoEl.innerHTML = generateFallbackLogoHTML(lineName, color, code);
                logoEl.style.background = 'transparent'; // Reset background as the generator handles it
            }
            
            // Populate Stations
            const list = document.getElementById('detail-stations');
            list.innerHTML = '';
            
            if (data.station_l) {
                data.station_l.forEach(st => {
                    const item = document.createElement('li');
                    item.className = 'station-item';
                    item.innerHTML = `
                        <div class="station-marker" style="background: ${color};"></div>
                        <div>${st.station_name}</div>
                    `;
                    list.appendChild(item);
                });
            }

            // Show Panel
            document.getElementById('line-details-panel').classList.add('active');
        }

        function hideLineDetails() {
            document.getElementById('line-details-panel').classList.remove('active');
        }

        // --- Helpers ---
        function getLineColor(name) {
            // Normalize input name for matching
            const normalize = (n) => n.replace(/^JR/, '').replace(/線$/, '').replace(/[（\(].*?[）\)]/g, '').trim();
            const normName = normalize(name);
            
            // 1. Try Normalized Match
            if (externalLineData[normName] && externalLineData[normName].color) {
                return externalLineData[normName].color;
            }
            
            // 2. Try Exact Match (Fallback)
            if (externalLineData[name] && externalLineData[name].color) {
                return externalLineData[name].color;
            }

            // 3. Fallback Heuristics (Generic)
            if (name.includes("JR")) return "#2ecc71"; // Generic JR Green
            if (name.includes("地下鉄") || name.includes("メトロ")) return "#999"; // Generic Subway Gray
            if (name.includes("新幹線")) return "#1E3586"; // Generic Shinkansen Blue
            return "#ccc"; // Default Gray
        }

        function getDistanceKm(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the earth in km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            const d = R * c; // Distance in km
            return d;
        }

        function deg2rad(deg) {
            return deg * (Math.PI/180);
        }

        function getCatmullRomSpline(points, numSegments) {
            if (points.length < 2) return points;
            const spline = [];
            const p = [points[0], ...points, points[points.length - 1]];
            for (let i = 0; i < p.length - 3; i++) {
                const p0 = p[i], p1 = p[i+1], p2 = p[i+2], p3 = p[i+3];
                for (let t = 0; t < 1; t += 1/numSegments) {
                    const t2 = t*t, t3 = t2*t;
                    const x = 0.5 * ((2*p1[0]) + (-p0[0]+p2[0])*t + (2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2 + (-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3);
                    const y = 0.5 * ((2*p1[1]) + (-p0[1]+p2[1])*t + (2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2 + (-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3);
                    spline.push([x, y]);
                }
            }
            spline.push(points[points.length - 1]);
            return spline;
        }

        function updateStatus(msg) {
            document.getElementById('status-bar').innerText = msg;
        }

        function toggleMode() {
            if (!map) return;
            isUnderground = !isUnderground;
            const body = document.body;
            const labelDay = document.getElementById('label-day');
            const labelNight = document.getElementById('label-night');
            
            if (isUnderground) {
                body.classList.add('dark-mode');
                labelDay.classList.remove('active'); labelDay.classList.add('inactive');
                labelNight.classList.add('active'); labelNight.classList.remove('inactive');
                
                // Switch Base Tile
                map.removeLayer('base-tiles');
                map.addLayer({
                    id: 'base-tiles',
                    type: 'raster',
                    source: 'carto-dark',
                    minzoom: 0,
                    maxzoom: 22
                }, 'real-tracks'); // Insert before tracks

                // Update Styles for Night
                map.setPaintProperty('stations-points', 'circle-color', ['get', 'color']);
                map.setPaintProperty('stations-points', 'circle-stroke-color', '#fff');
                map.setPaintProperty('stations-labels', 'text-color', '#fff');
                map.setPaintProperty('stations-labels', 'text-halo-color', '#000');
                map.setPaintProperty('real-tracks', 'line-color', '#444');

            } else {
                body.classList.remove('dark-mode');
                labelDay.classList.add('active'); labelDay.classList.remove('inactive');
                labelNight.classList.remove('active'); labelNight.classList.add('inactive');

                // Switch Base Tile
                map.removeLayer('base-tiles');
                map.addLayer({
                    id: 'base-tiles',
                    type: 'raster',
                    source: 'carto-light',
                    minzoom: 0,
                    maxzoom: 22
                }, 'real-tracks');

                // Update Styles for Day
                map.setPaintProperty('stations-points', 'circle-color', '#fff');
                map.setPaintProperty('stations-points', 'circle-stroke-color', '#555');
                map.setPaintProperty('stations-labels', 'text-color', '#000');
                map.setPaintProperty('stations-labels', 'text-halo-color', '#fff');
                map.setPaintProperty('real-tracks', 'line-color', '#888');
            }
        }

        function generateFallbackLogoHTML(lineName, color, code) {
            // 1. Determine Style (Square for JR/Private, Circle for Subway)
            const isSubway = lineName.includes("地下鉄") || lineName.includes("メトロ") || lineName.includes("都営");
            
            // 2. Determine Text (Code > Initial > Kanji)
            let text = code;
            if (!text) {
                // Try to guess initial from common names if no code provided
                if (lineName.includes("山手")) text = "JY";
                else if (lineName.includes("京浜東北")) text = "JK";
                else if (lineName.includes("中央")) text = "JC";
                else if (lineName.includes("総武")) text = "JB";
                else if (lineName.includes("常磐")) text = "JJ";
                else if (lineName.includes("銀座")) text = "G";
                else if (lineName.includes("丸ノ内")) text = "M";
                else if (lineName.includes("日比谷")) text = "H";
                else if (lineName.includes("東西")) text = "T";
                else if (lineName.includes("千代田")) text = "C";
                else if (lineName.includes("有楽町")) text = "Y";
                else if (lineName.includes("半蔵門")) text = "Z";
                else if (lineName.includes("南北")) text = "N";
                else if (lineName.includes("副都心")) text = "F";
                else if (lineName.includes("新宿")) text = "S";
                else if (lineName.includes("浅草")) text = "A";
                else if (lineName.includes("三田")) text = "I";
                else if (lineName.includes("大江戸")) text = "E";
                else {
                    // Fallback to first character (Kanji)
                    text = lineName.replace(/^JR/, '').charAt(0);
                }
            }

            // 3. Generate HTML
            if (isSubway) {
                // Circle Style (Tokyo Metro / Toei style)
                // Outer circle: Color
                // Inner circle: White
                // Text: Color or Black
                return `
                    <div style="
                        width: 100%; height: 100%;
                        background: ${color};
                        border-radius: 50%;
                        display: flex; align-items: center; justify-content: center;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    ">
                        <div style="
                            width: 75%; height: 75%;
                            background: white;
                            border-radius: 50%;
                            display: flex; align-items: center; justify-content: center;
                            color: #333;
                            font-family: 'Arial', sans-serif;
                            font-weight: 900;
                            font-size: 16px;
                        ">${text}</div>
                    </div>
                `;
            } else {
                // Square Style (JR style)
                // Rounded square: Color
                // Text: White (or Black if color is too light)
                return `
                    <div style="
                        width: 100%; height: 100%;
                        background: ${color};
                        border-radius: 6px;
                        display: flex; align-items: center; justify-content: center;
                        color: white;
                        font-family: 'Arial', sans-serif;
                        font-weight: bold;
                        font-size: 18px;
                        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
                        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    ">
                        ${text}
                    </div>
                `;
            }
        }

        function toggleLegend() {
            const list = document.getElementById('legend-list');
            list.classList.toggle('show');
            if (list.classList.contains('show') && list.children.length === 0) populateLegend();
        }

        function populateLegend() {
            const list = document.getElementById('legend-list');
            list.innerHTML = '';
            
            // Use external data if available, otherwise fallback
            const entries = Object.entries(externalLineData).length > 0 
                ? Object.entries(externalLineData).slice(0, 20) // Limit to 20 for performance
                : [["JR山手線", "#9ACD32"], ["JR中央線", "#FF8C00"], ["銀座線", "#F39C12"]];

            for (const [name, data] of entries) {
                const color = data.color || data; // Handle both object and simple string/array
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<div class="color-box" style="background: ${color};"></div>${name}`;
                list.appendChild(item);
            }
        }
    </script>
</body>
</html>