<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RailVerse (全国版) - MapLibre GL JS Edition</title>
    
    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    
    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; background: #000; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            width: 320px;
            backdrop-filter: blur(10px);
            transition: background 0.3s, color 0.3s;
            max-height: 90vh;
            overflow-y: auto;
        }

        .dark-mode #ui-layer {
            background: rgba(20, 20, 30, 0.85);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
        }

        h1 { margin: 0 0 5px 0; font-size: 24px; font-weight: 700; letter-spacing: -0.5px; }
        .subtitle { font-size: 12px; color: #666; margin-bottom: 15px; }
        .dark-mode .subtitle { color: #aaa; }

        /* Status Bar */
        #status-bar {
            font-size: 11px;
            padding: 5px 10px;
            background: #eee;
            border-radius: 4px;
            margin-bottom: 15px;
            color: #555;
            border-left: 4px solid #2ecc71;
        }
        .dark-mode #status-bar { background: #333; color: #ccc; border-left-color: #00f2ff; }

        /* Toggle Switch */
        .mode-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #eee;
            border-radius: 30px;
            padding: 5px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s;
            margin-bottom: 15px;
        }
        .dark-mode .mode-switch { background: #333; }

        .mode-label {
            flex: 1;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            z-index: 2;
            padding: 8px 0;
            transition: color 0.3s;
        }
        
        .mode-indicator {
            position: absolute;
            width: 50%;
            height: calc(100% - 10px);
            background: #fff;
            border-radius: 25px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            left: 5px;
        }
        
        .dark-mode .mode-indicator {
            transform: translateX(100%);
            background: #00f2ff; /* Neon Cyan */
            box-shadow: 0 0 15px #00f2ff;
        }

        .active { color: #000; }
        .dark-mode .active { color: #000; text-shadow: none; }
        .inactive { color: #999; }

        /* Legend Panel */
        #legend-container {
            margin-top: 15px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        .legend-toggle {
            cursor: pointer;
            font-size: 12px;
            color: #555;
            text-decoration: underline;
            margin-bottom: 5px;
            display: block;
        }
        .legend-list {
            display: none; /* Hidden by default */
            max-height: 200px;
            overflow-y: auto;
        }
        .legend-list.show {
            display: block;
        }
        .legend-item { display: flex; align-items: center; margin-top: 8px; font-size: 12px; }
        .color-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }

        /* Line Details Panel */
        #line-details-panel {
            position: absolute;
            top: 20px;
            right: -350px; /* Hidden by default */
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 8px;
            box-shadow: -4px 0 12px rgba(0,0,0,0.1);
            transition: right 0.3s ease-in-out;
            z-index: 2;
            max-height: 90vh;
            overflow-y: auto;
        }
        #line-details-panel.active {
            right: 20px;
        }
        .dark-mode #line-details-panel {
            background: rgba(20, 20, 30, 0.95);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .line-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .dark-mode .line-header { border-bottom-color: #444; }
        .line-logo {
            width: 40px;
            height: 40px;
            background: #ccc;
            border-radius: 4px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .line-info h2 {
            margin: 0;
            font-size: 18px;
        }
        .line-info p {
            margin: 2px 0 0;
            font-size: 12px;
            color: #666;
        }
        .dark-mode .line-info p { color: #aaa; }
        .station-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .station-item {
            padding: 8px 5px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 13px;
            display: flex;
            align-items: center;
        }
        .dark-mode .station-item { border-bottom-color: #444; }
        .station-marker {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
            margin-right: 10px;
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-size: 18px;
            color: #999;
        }
        .close-btn:hover { color: #333; }
    </style>
</head>
<body>

    <div id="map"></div>
    
    <div id="ui-layer">
        <h1>RailVerse <span style="font-size: 12px; font-weight: normal; opacity: 0.7;">(MapLibre版)</span></h1>
        <div class="subtitle">WebGL高速描画エンジン搭載</div>

        <div id="status-bar">データを読み込み中...</div>

        <div class="mode-switch" onclick="toggleMode()">
            <div class="mode-indicator"></div>
            <div class="mode-label active" id="label-day">DAY (地上)</div>
            <div class="mode-label inactive" id="label-night">NIGHT (地下)</div>
        </div>

        <div id="legend-container">
            <div class="legend-toggle" onclick="toggleLegend()">路線凡例を表示/非表示</div>
            <div id="legend-list" class="legend-list">
                <!-- Dynamically populated -->
            </div>
        </div>
    </div>

    <div id="line-details-panel">
        <div class="close-btn" onclick="hideLineDetails()">×</div>
        <div class="line-header">
            <div class="line-logo" id="detail-logo">JR</div>
            <div class="line-info">
                <h2 id="detail-name">路線名</h2>
                <p id="detail-company">鉄道会社</p>
            </div>
        </div>
        <div id="detail-content">
            <p style="font-size:12px; color:#888; margin-bottom:5px;">駅一覧:</p>
            <ul class="station-list" id="detail-stations">
                <!-- Stations go here -->
            </ul>
        </div>
    </div>

    <script>
        // --- Configuration ---
        // (Regions removed)

        // --- State ---
        let map;
        let isUnderground = false;
        const loadedRealTrackExtents = [];
        const lineDataCache = {}; // Cache for station lists: { lineCd: { ...data } }
        
        // External Data Cache
        let externalLineData = {}; // Map<LineName, { color, logo, company }>

        // GeoJSON Data Store
        let geojsonData = {
            type: 'FeatureCollection',
            features: []
        };

        // Overpass State
        let isOverpassLoading = false;
        let overpassDebounceTimer = null;

        // --- Initialization ---
        window.onload = async function() {
            initMap();
            await fetchExternalMetadata();
            loadAllRailways(); // Start loading everything
        };

        async function fetchExternalMetadata() {
            updateStatus("外部メタデータ(Mini Tokyo 3D等)を取得中...");
            try {
                // 1. Fetch Colors from Mini Tokyo 3D
                const colorRes = await fetch('https://raw.githubusercontent.com/nagix/mini-tokyo-3d/master/data/railways.json');
                const colorData = await colorRes.json();

                // 2. Fetch Logos from Open Data JP Railway Lines
                const logoRes = await fetch('https://raw.githubusercontent.com/piuccio/open-data-jp-railway-lines/master/lines.json');
                const logoData = await logoRes.json();

                // 3. Build Lookup Map
                // Key: Japanese Line Name (normalized) -> Value: { color, logo }
                
                // Process Colors
                colorData.forEach(line => {
                    if (line.title && line.title.ja) {
                        const name = line.title.ja;
                        if (!externalLineData[name]) externalLineData[name] = {};
                        externalLineData[name].color = line.color;
                        // Try to guess company from ID (e.g. "JR-East" -> "JR東日本")
                        if (line.id.includes("JR-East")) externalLineData[name].company = "JR東日本";
                        else if (line.id.includes("TokyoMetro")) externalLineData[name].company = "東京メトロ";
                        else if (line.id.includes("Toei")) externalLineData[name].company = "都営地下鉄";
                    }
                });

                // Process Logos
                logoData.forEach(line => {
                    // This dataset uses "code" like "JR-East.Yamanote" similar to Mini Tokyo 3D
                    // But we need to match by name or ID if possible.
                    // Let's try to match by ID first if we can infer it, or just use the name if available.
                    // The dataset has "name_ja".
                    if (line.name_ja) {
                        const name = line.name_ja;
                        if (!externalLineData[name]) externalLineData[name] = {};
                        if (line.logo) externalLineData[name].logo = line.logo;
                        if (line.station_size) externalLineData[name].logoText = line.code.split('.').pop().substring(0, 2).toUpperCase(); // Fallback text
                    }
                });

                console.log("External metadata loaded:", Object.keys(externalLineData).length, "lines");
                updateStatus("外部メタデータの読み込み完了");

            } catch (e) {
                console.error("Failed to load external metadata", e);
                updateStatus("外部メタデータの読み込みに失敗しました (デフォルト色を使用)");
            }
        }

        // (initUI removed)

        function initMap() {
            map = new maplibregl.Map({
                container: 'map',
                // Use local fonts for CJK to improve performance and avoid 404s
                localIdeographFontFamily: "'Meiryo', 'Hiragino Kaku Gothic ProN', 'MS PGothic', 'sans-serif'",
                style: {
                    version: 8,
                    // Use Geolonia's public glyphs for reliable Japanese font support
                    glyphs: "https://glyphs.geolonia.com/{fontstack}/{range}.pbf",
                    sources: {
                        'carto-light': {
                            type: 'raster',
                            tiles: ['https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'],
                            tileSize: 256,
                            attribution: '&copy; OSM &copy; CARTO'
                        },
                        'carto-dark': {
                            type: 'raster',
                            tiles: ['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'],
                            tileSize: 256,
                            attribution: '&copy; OSM &copy; CARTO'
                        },
                        'railways': {
                            type: 'geojson',
                            data: geojsonData
                        }
                    },
                    layers: [
                        {
                            id: 'base-tiles',
                            type: 'raster',
                            source: 'carto-light',
                            minzoom: 0,
                            maxzoom: 22
                        },
                        // --- Real Tracks (Overpass) ---
                        {
                            id: 'real-tracks',
                            type: 'line',
                            source: 'railways',
                            filter: ['==', ['get', 'type'], 'real-track'],
                            paint: {
                                'line-color': '#888',
                                'line-width': 1,
                                'line-opacity': 0.6
                            }
                        },
                        // --- Spline Lines (Glow/Casing) ---
                        {
                            id: 'rail-lines-glow',
                            type: 'line',
                            source: 'railways',
                            filter: ['in', ['get', 'type'], ['literal', ['ground', 'subway']]],
                            paint: {
                                'line-color': ['get', 'color'],
                                'line-width': [
                                    'interpolate', ['linear'], ['zoom'],
                                    5, 2,
                                    12, 8
                                ],
                                'line-opacity': 0.3,
                                'line-blur': 2
                            }
                        },
                        // --- Spline Lines (Core) ---
                        {
                            id: 'rail-lines-core',
                            type: 'line',
                            source: 'railways',
                            filter: ['in', ['get', 'type'], ['literal', ['ground', 'subway']]],
                            paint: {
                                'line-color': ['get', 'color'],
                                'line-width': [
                                    'interpolate', ['linear'], ['zoom'],
                                    5, 1,
                                    12, 3
                                ]
                            }
                        },
                        // --- Stations (Points) ---
                        {
                            id: 'stations-points',
                            type: 'circle',
                            source: 'railways',
                            filter: ['==', ['get', 'type'], 'station'],
                            minzoom: 9, // Performance: Only show dots when zoomed in
                            paint: {
                                'circle-radius': [
                                    'interpolate', ['linear'], ['zoom'],
                                    9, 2,
                                    14, 5
                                ],
                                'circle-color': '#fff',
                                'circle-stroke-width': 1,
                                'circle-stroke-color': '#555'
                            }
                        },
                        // --- Station Labels ---
                        {
                            id: 'stations-labels',
                            type: 'symbol',
                            source: 'railways',
                            filter: ['==', ['get', 'type'], 'station'],
                            minzoom: 12, // Performance: Only show text when very close
                            layout: {
                                'text-field': ['get', 'name'],
                                // Use Noto Sans CJK JP Bold which is available on Geolonia's server
                                'text-font': ['Noto Sans CJK JP Bold'],
                                'text-size': 12,
                                'text-offset': [0, 1.2],
                                'text-anchor': 'top'
                            },
                            paint: {
                                'text-color': '#000',
                                'text-halo-color': '#fff',
                                'text-halo-width': 2
                            }
                        }
                    ]
                },
                center: [139.7671, 35.6812], // Default to Tokyo
                zoom: 10
            });

            // Popup
            const popup = new maplibregl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mouseenter', 'stations-points', (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const coordinates = e.features[0].geometry.coordinates.slice();
                const description = e.features[0].properties.name;
                popup.setLngLat(coordinates).setHTML(description).addTo(map);
            });

            map.on('mouseleave', 'stations-points', () => {
                map.getCanvas().style.cursor = '';
                popup.remove();
            });

            // Dynamic Loading (Global) with Debounce
            map.on('moveend', () => {
                if (overpassDebounceTimer) clearTimeout(overpassDebounceTimer);
                overpassDebounceTimer = setTimeout(loadRealTracksInView, 500); // Wait 500ms after move ends
            });

            // Click Listeners for Line Details
            const lineLayers = ['rail-lines-core', 'rail-lines-glow'];
            lineLayers.forEach(layerId => {
                map.on('click', layerId, (e) => {
                    const props = e.features[0].properties;
                    if (props.lineCd) {
                        showLineDetails(props.lineCd);
                    }
                });
                
                // Change cursor on hover
                map.on('mouseenter', layerId, () => {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', layerId, () => {
                    map.getCanvas().style.cursor = '';
                });
            });
        }

        // --- Core Logic ---
        async function loadAllRailways() {
            updateStatus("全国の路線データを読み込み開始...");
            
            // Iterate through all prefectures (1 to 47)
            // To avoid freezing the UI, we process them in chunks
            const PREF_COUNT = 47;
            let totalLines = 0;

            for (let prefCode = 1; prefCode <= PREF_COUNT; prefCode++) {
                updateStatus(`都道府県データ読み込み中: ${prefCode}/${PREF_COUNT}`);
                const count = await fetchPrefectureLines(prefCode);
                totalLines += count;
                
                // Small delay to let UI breathe
                if (prefCode % 5 === 0) await new Promise(r => setTimeout(r, 100));
            }
            
            updateStatus(`全データ読み込み完了: ${totalLines}路線`);
            // Trigger initial Overpass load
            loadRealTracksInView();
        }

        async function fetchPrefectureLines(prefCode) {
            const url = `https://ny-a.github.io/ekidata/api/p/${prefCode}.json`;
            try {
                const response = await fetch(url);
                if (!response.ok) return 0;
                
                const data = await response.json();
                const lines = data.line;
                if (!lines) return 0;

                const BATCH_SIZE = 50; 
                let newFeatures = [];

                for (let i = 0; i < lines.length; i += BATCH_SIZE) {
                    const batch = lines.slice(i, i + BATCH_SIZE);
                    const batchFeatures = await Promise.all(batch.map(l => fetchLineDetails(l.line_cd, l.line_name)));
                    
                    batchFeatures.flat().forEach(f => {
                        if (f) newFeatures.push(f);
                    });

                    if (newFeatures.length > 0) {
                        geojsonData.features.push(...newFeatures);
                        map.getSource('railways').setData(geojsonData);
                        newFeatures = [];
                    }
                    await new Promise(r => setTimeout(r, 10));
                }
                return lines.length;
            } catch (e) {
                console.warn(`Failed to load pref ${prefCode}`, e);
                return 0;
            }
        }

        async function fetchLineDetails(lineCd, lineName) {
            const url = `https://ny-a.github.io/ekidata/api/l/${lineCd}.json`;
            try {
                const response = await fetch(url);
                if (!response.ok) return [];
                const data = await response.json();
                const stations = data.station_l;
                if (!stations) return [];

                // Cache data for UI
                lineDataCache[lineCd] = data;

                const color = getLineColor(lineName);
                const isSubway = lineName.includes("地下鉄") || lineName.includes("メトロ") || lineName.includes("都営");
                
                const rawPath = [];
                const features = [];

                stations.forEach(st => {
                    rawPath.push([st.lon, st.lat]);
                    features.push({
                        type: 'Feature',
                        geometry: { type: 'Point', coordinates: [st.lon, st.lat] },
                        properties: {
                            type: 'station',
                            color: color,
                            name: st.station_name,
                            lineCd: lineCd,
                            lineName: lineName
                        }
                    });
                });

                if (rawPath.length > 1) {
                    // Hide schematic lines for long-distance trains or sparse stops to avoid "straight line" artifacts
                    // These will be covered by Overpass (Real Tracks)
                    if (lineName.includes("成田エクスプレス") || 
                        lineName.includes("新幹線") || 
                        lineName.includes("特急") || 
                        lineName.includes("ライナー")) {
                        return features;
                    }

                    const smoothedPath = getCatmullRomSpline(rawPath, 4);
                    features.push({
                        type: 'Feature',
                        geometry: { type: 'LineString', coordinates: smoothedPath },
                        properties: {
                            type: isSubway ? 'subway' : 'ground',
                            color: color,
                            lineCd: lineCd,
                            lineName: lineName
                        }
                    });
                }
                return features;

            } catch (e) {
                return [];
            }
        }

        async function loadRealTracksInView() {
            if (isOverpassLoading) return;

            const zoom = map.getZoom();
            // Safety check: Don't load Overpass if zoom is too low (too much data)
            // Even if user said "always", loading at zoom 5 will fail.
            if (zoom < 7) return;

            const bounds = map.getBounds();
            const center = bounds.getCenter();
            
            // Check if current view is already covered by loaded extents
            // We check if the center is in a loaded box, AND if the box is reasonably large enough
            const isLoaded = loadedRealTrackExtents.some(b => b.contains(center));
            if (isLoaded) return;

            isOverpassLoading = true;
            updateStatus("詳細線路データを取得中 (Overpass API)...");

            // Expand bounds slightly to avoid frequent re-fetching
            const expandedBounds = new maplibregl.LngLatBounds(
                [bounds.getWest() - 0.02, bounds.getSouth() - 0.02],
                [bounds.getEast() + 0.02, bounds.getNorth() + 0.02]
            );
            
            const bbox = `${expandedBounds.getSouth()},${expandedBounds.getWest()},${expandedBounds.getNorth()},${expandedBounds.getEast()}`;
            const query = `
                [out:json][timeout:25];
                (
                  way["railway"~"^(rail|subway|monorail)$"]["service"!~"^(yard|siding|spur)$"](${bbox});
                );
                out geom;
            `;
            
            try {
                const response = await fetch("https://overpass-api.de/api/interpreter", { method: 'POST', body: query });
                if (!response.ok) {
                    if (response.status === 429) {
                        console.warn("Overpass API rate limit exceeded. Retrying later.");
                    }
                    throw new Error("Overpass API request failed");
                }
                
                const data = await response.json();
                const newFeatures = [];
                
                data.elements.forEach(element => {
                    if (element.type === 'way' && element.geometry) {
                        const coords = element.geometry.map(pt => [pt.lon, pt.lat]);
                        newFeatures.push({
                            type: 'Feature',
                            geometry: { type: 'LineString', coordinates: coords },
                            properties: {
                                type: 'real-track',
                                color: '#888'
                            }
                        });
                    }
                });
                
                if (newFeatures.length > 0) {
                    geojsonData.features.push(...newFeatures);
                    map.getSource('railways').setData(geojsonData);
                    updateStatus(`実形状データ: ${newFeatures.length}件を追加読み込みしました`);
                    loadedRealTrackExtents.push(expandedBounds);
                } else {
                    updateStatus("実形状データ: 範囲内に見つかりませんでした");
                }
                
            } catch (e) {
                console.warn("Dynamic Overpass fetch failed", e);
                updateStatus("詳細データの取得に失敗しました");
            } finally {
                isOverpassLoading = false;
            }
        }

        // --- UI Logic ---
        function showLineDetails(lineCd) {
            const data = lineDataCache[lineCd];
            if (!data) return;

            const lineName = data.line_name;
            const cleanName = lineName.replace(/^JR/, '');
            
            // Fetch from External Data
            const meta = externalLineData[cleanName] || externalLineData[lineName] || {};
            
            // Fallback for metadata
            const color = meta.color || getLineColor(lineName);
            const logoUrl = meta.logo; // URL if available
            const company = meta.company || "鉄道会社";

            // Update UI
            document.getElementById('detail-name').innerText = lineName;
            document.getElementById('detail-company').innerText = company;
            
            const logoEl = document.getElementById('detail-logo');
            logoEl.style.backgroundColor = color;
            
            if (logoUrl) {
                logoEl.innerHTML = `<img src="${logoUrl}" style="width:100%; height:100%; object-fit:contain;">`;
                logoEl.style.background = 'transparent'; // Use transparent if image exists
            } else {
                logoEl.innerHTML = lineName.charAt(0);
                logoEl.style.background = color;
            }
            
            // Populate Stations
            const list = document.getElementById('detail-stations');
            list.innerHTML = '';
            
            if (data.station_l) {
                data.station_l.forEach(st => {
                    const item = document.createElement('li');
                    item.className = 'station-item';
                    item.innerHTML = `
                        <div class="station-marker" style="background: ${color};"></div>
                        <div>${st.station_name}</div>
                    `;
                    list.appendChild(item);
                });
            }

            // Show Panel
            document.getElementById('line-details-panel').classList.add('active');
        }

        function hideLineDetails() {
            document.getElementById('line-details-panel').classList.remove('active');
        }

        // --- Helpers ---
        function getLineColor(name) {
            // 1. Try External Data (Exact Match)
            // Ekidata names often have "JR" prefix or "線" suffix.
            // Mini Tokyo 3D names are usually clean (e.g. "山手線").
            
            // Normalize input name: Remove "JR" prefix for matching
            const cleanName = name.replace(/^JR/, '');
            
            if (externalLineData[cleanName] && externalLineData[cleanName].color) {
                return externalLineData[cleanName].color;
            }
            if (externalLineData[name] && externalLineData[name].color) {
                return externalLineData[name].color;
            }

            // 2. Fallback Heuristics (Generic)
            if (name.includes("JR")) return "#2ecc71"; // Generic JR Green
            if (name.includes("地下鉄") || name.includes("メトロ")) return "#999"; // Generic Subway Gray
            if (name.includes("新幹線")) return "#1E3586"; // Generic Shinkansen Blue
            return "#ccc"; // Default Gray
        }

        function getCatmullRomSpline(points, numSegments) {
            if (points.length < 2) return points;
            const spline = [];
            const p = [points[0], ...points, points[points.length - 1]];
            for (let i = 0; i < p.length - 3; i++) {
                const p0 = p[i], p1 = p[i+1], p2 = p[i+2], p3 = p[i+3];
                for (let t = 0; t < 1; t += 1/numSegments) {
                    const t2 = t*t, t3 = t2*t;
                    const x = 0.5 * ((2*p1[0]) + (-p0[0]+p2[0])*t + (2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2 + (-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3);
                    const y = 0.5 * ((2*p1[1]) + (-p0[1]+p2[1])*t + (2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2 + (-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3);
                    spline.push([x, y]);
                }
            }
            spline.push(points[points.length - 1]);
            return spline;
        }

        function updateStatus(msg) {
            document.getElementById('status-bar').innerText = msg;
        }

        function toggleMode() {
            if (!map) return;
            isUnderground = !isUnderground;
            const body = document.body;
            const labelDay = document.getElementById('label-day');
            const labelNight = document.getElementById('label-night');
            
            if (isUnderground) {
                body.classList.add('dark-mode');
                labelDay.classList.remove('active'); labelDay.classList.add('inactive');
                labelNight.classList.add('active'); labelNight.classList.remove('inactive');
                
                // Switch Base Tile
                map.removeLayer('base-tiles');
                map.addLayer({
                    id: 'base-tiles',
                    type: 'raster',
                    source: 'carto-dark',
                    minzoom: 0,
                    maxzoom: 22
                }, 'real-tracks'); // Insert before tracks

                // Update Styles for Night
                map.setPaintProperty('stations-points', 'circle-color', ['get', 'color']);
                map.setPaintProperty('stations-points', 'circle-stroke-color', '#fff');
                map.setPaintProperty('stations-labels', 'text-color', '#fff');
                map.setPaintProperty('stations-labels', 'text-halo-color', '#000');
                map.setPaintProperty('real-tracks', 'line-color', '#444');

            } else {
                body.classList.remove('dark-mode');
                labelDay.classList.add('active'); labelDay.classList.remove('inactive');
                labelNight.classList.remove('active'); labelNight.classList.add('inactive');

                // Switch Base Tile
                map.removeLayer('base-tiles');
                map.addLayer({
                    id: 'base-tiles',
                    type: 'raster',
                    source: 'carto-light',
                    minzoom: 0,
                    maxzoom: 22
                }, 'real-tracks');

                // Update Styles for Day
                map.setPaintProperty('stations-points', 'circle-color', '#fff');
                map.setPaintProperty('stations-points', 'circle-stroke-color', '#555');
                map.setPaintProperty('stations-labels', 'text-color', '#000');
                map.setPaintProperty('stations-labels', 'text-halo-color', '#fff');
                map.setPaintProperty('real-tracks', 'line-color', '#888');
            }
        }

        function toggleLegend() {
            const list = document.getElementById('legend-list');
            list.classList.toggle('show');
            if (list.classList.contains('show') && list.children.length === 0) populateLegend();
        }

        function populateLegend() {
            const list = document.getElementById('legend-list');
            list.innerHTML = '';
            
            // Use external data if available, otherwise fallback
            const entries = Object.entries(externalLineData).length > 0 
                ? Object.entries(externalLineData).slice(0, 20) // Limit to 20 for performance
                : [["JR山手線", "#9ACD32"], ["JR中央線", "#FF8C00"], ["銀座線", "#F39C12"]];

            for (const [name, data] of entries) {
                const color = data.color || data; // Handle both object and simple string/array
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<div class="color-box" style="background: ${color};"></div>${name}`;
                list.appendChild(item);
            }
        }
    </script>
</body>
</html>